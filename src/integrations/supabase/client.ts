// This file is automatically generated. Do not edit it directly.
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types';

type SupabaseEnvKey =
  | "VITE_SUPABASE_URL"
  | "VITE_SUPABASE_ANON_KEY"
  | "VITE_SUPABASE_PUBLISHABLE_KEY"
  | "SUPABASE_URL"
  | "SUPABASE_ANON_KEY"
  | "SUPABASE_KEY"
  | "NEXT_PUBLIC_SUPABASE_URL"
  | "NEXT_PUBLIC_SUPABASE_ANON_KEY"
  | "PUBLIC_SUPABASE_URL"
  | "PUBLIC_SUPABASE_ANON_KEY";

const getImportMetaEnv = () => {
  try {
    return import.meta.env as unknown as Record<SupabaseEnvKey, string | undefined>;
  } catch (_error) {
    return undefined;
  }
};

const importMetaEnv = getImportMetaEnv();
const processEnv =
  typeof process !== "undefined"
    ? (process.env as Record<SupabaseEnvKey, string | undefined>)
    : undefined;

const getEnvValue = (...keys: SupabaseEnvKey[]) => {
  for (const key of keys) {
    const value = importMetaEnv?.[key] ?? processEnv?.[key];
    if (value) {
      return value;
    }
  }
  return undefined;
};

const SUPABASE_URL = getEnvValue(
  "VITE_SUPABASE_URL",
  "SUPABASE_URL",
  "NEXT_PUBLIC_SUPABASE_URL",
  "PUBLIC_SUPABASE_URL"
);
const SUPABASE_ANON_KEY = getEnvValue(
  "VITE_SUPABASE_ANON_KEY",
  "VITE_SUPABASE_PUBLISHABLE_KEY",
  "SUPABASE_ANON_KEY",
  "SUPABASE_KEY",
  "NEXT_PUBLIC_SUPABASE_ANON_KEY",
  "PUBLIC_SUPABASE_ANON_KEY"
);

const storage = typeof localStorage === "undefined" ? undefined : localStorage;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";
const MISSING_SUPABASE_MESSAGE =
  "Supabase environment variables are not configured. Supabase-backed features are disabled until VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY (or their equivalents) are set.";

const missingSupabaseError = new Error(MISSING_SUPABASE_MESSAGE);
let hasWarnedAboutMissingSupabase = false;

const warnAboutMissingSupabase = () => {
  if (!hasWarnedAboutMissingSupabase) {
    console.warn(MISSING_SUPABASE_MESSAGE);
    hasWarnedAboutMissingSupabase = true;
  }
};

const createQueryBuilderStub = () => {
  warnAboutMissingSupabase();
  const asyncResult = Promise.resolve({ data: null, error: missingSupabaseError });
  const proxy: any = new Proxy(
    {},
    {
      get(_target, prop) {
        if (prop === "then") {
          return asyncResult.then.bind(asyncResult);
        }
        if (prop === "catch") {
          return asyncResult.catch.bind(asyncResult);
        }
        if (prop === "finally") {
          return asyncResult.finally.bind(asyncResult);
        }
        if (prop === "throwOnError") {
          return () => proxy;
        }
        if (prop === "maybeSingle" || prop === "single") {
          return () => asyncResult;
        }

        return () => proxy;
      },
    }
  );

  return proxy;
};

const createSupabaseStub = (): SupabaseClient<Database> => {
  const asyncData = async <T>(data: T | null = null) => {
    warnAboutMissingSupabase();
    return { data, error: missingSupabaseError };
  };

  const asyncErrorOnly = async () => {
    warnAboutMissingSupabase();
    return { error: missingSupabaseError };
  };

  const channelStub = {
    on: () => channelStub,
    subscribe: (callback?: (status: string) => void) => {
      warnAboutMissingSupabase();
      if (callback) {
        try {
          callback("CHANNEL_ERROR");
        } catch (_error) {
          // Ignore callback errors in stub mode
        }
      }
      return Promise.resolve({ error: missingSupabaseError });
    },
    unsubscribe: () => {
      warnAboutMissingSupabase();
    },
    send: () => asyncErrorOnly(),
  };

  return {
    auth: {
      onAuthStateChange: () => {
        warnAboutMissingSupabase();
        return { data: { subscription: { unsubscribe: () => undefined } } };
      },
      getSession: () => asyncData({ session: null }),
      getUser: () => asyncData({ user: null }),
      signInWithPassword: () => asyncData({ user: null, session: null }),
      signInWithOAuth: () => asyncData(null),
      signUp: () => asyncData({ user: null, session: null }),
      signOut: () => asyncErrorOnly(),
    },
    from: () => createQueryBuilderStub(),
    rpc: () => asyncData(null),
    channel: () => channelStub,
    removeChannel: () => {
      warnAboutMissingSupabase();
    },
    functions: {
      invoke: () => asyncData(null),
    },
    storage: {
      from: () => ({
        upload: () => asyncData(null),
        update: () => asyncData(null),
        remove: () => asyncData(null),
        download: () => asyncData(null),
        getPublicUrl: () => {
          warnAboutMissingSupabase();
          return { data: { publicUrl: null }, error: missingSupabaseError };
        },
      }),
    },
  } as unknown as SupabaseClient<Database>;
};

const isSupabaseConfigured = Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);

export const supabase = isSupabaseConfigured
  ? createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        storage,
        persistSession: Boolean(storage),
        autoRefreshToken: Boolean(storage),
      },
    })
  : createSupabaseStub();

export const supabaseConfigured = isSupabaseConfigured;
